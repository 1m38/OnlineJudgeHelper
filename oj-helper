#!/usr/bin/env python
# coding: utf-8
"""docstring"""

from __future__ import print_function
from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
import os
import sys
import re
import subprocess
import json
import shutil
import time

# compatible with Python2
if sys.version_info.major == 2:
    input = raw_input

re_sample_comment = re.compile(r"/\* (.+) \*/")
re_isFloat = re.compile('^[+-]?(\d*\.\d+|\d+\.?\d*)([eE][+-]?\d+|)\Z')

def input_lines(prompt=None):
    lines = ""
    if prompt:
        print(prompt)
    while True:
        try:
            lines += input()
            lines += "\n"
        except EOFError:
            return lines


def parse_sample(qid):
    try:
        with open(qid + ".sample", "r") as f:
            sample_txt = f.read()
    except IOError:
        print("File '{}' not found.".format(qid + ".sample"))
        sys.exit(1)
    test_list = []
    sample_id = None
    for line in sample_txt.split("\n"):
        m = re_sample_comment.match(line)
        if m:
            sample_id = m.group(1)
            test_list.append([sample_id, ""])
        elif sample_id is not None:
            test_list[-1][1] += line + "\n"
    # 末尾の改行を削除
    if sample_id is not None:
        test_list[-1][1] = test_list[-1][1][:-1]
    return test_list


def add_sample(qid, test_id, test_str, out_str):
    with open(qid + ".sample", "a") as f:
        f.write("/* Test {} */\n".format(test_id))
        f.write(test_str)
        f.write("/* Output {} */\n".format(test_id))
        f.write(out_str)
    print("Added test case {}.".format(test_id))


def setup(args, config):
    contest = args.contest_name
    pnumber = args.problem_number
    dirname = os.path.join(contest, pnumber)
    script_dir = os.path.dirname(os.path.realpath(__file__))
    template_dir = config["templates"].format(src_dir=script_dir)
    template_file = os.path.join(template_dir, "template.{}".format(args.lang))
    script_path = args.file_name if args.file_name is not None \
        else "{}.{}".format(pnumber, args.lang)
    script_path = os.path.join(dirname, script_path)
    sample_path = os.path.join(dirname, "{}.sample".format(pnumber))
    if not os.path.exists(dirname):
        os.makedirs(dirname)
    if os.path.exists(template_file):
        shutil.copyfile(template_file, script_path)
    else:
        print("Template file not found. Create blank file.")
        with open(script_path, "w") as f:
            f.write("")
    # 空のsampleファイル作成
    with open(sample_path, "w") as f:
        f.write("")


def add_test(args, qid):
    test_list = parse_sample(qid)
    test_id = int(test_list[-1][0][7:]) + 1 if len(test_list) > 0 else 0
    test_str = input_lines(prompt="TestCase {}:".format(test_id))
    out_str = input_lines(prompt="Output {}:".format(test_id))
    add_sample(qid, test_id, test_str, out_str)


def run_cmd(cmd, input_line=None, timeout=10):
    tle = False
    t = time.time()
    p = subprocess.Popen(cmd, shell=True,
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE,
                         universal_newlines=True)
    stdout_data, stderr_data = ("", "")
    try:
        stdout_data, stderr_data = p.communicate(timeout=timeout,
                                                 input=input_line)
    except subprocess.TimeoutExpired:
        tle = True
    ts = time.time() - t
    return (p.returncode, stdout_data, stderr_data, ts, tle)

def chk_output_floatError(stdout, expect):
    result = True
    for lo, le in zip(stdout.split("\n"), expect.split("\n")):
        if re_isFloat.match(le):
            flo = float(lo)
            fle = float(le)
            if abs(flo - fle) < 1e-8:
                result *= True
            else:
                result *= False
        else:
            result *= lo == le
        return result

def run_test(args, config, qid):
    if args.file_name:
        fname = args.file_name
    else:
        fname = "{}.{}".format(qid, args.lang)
    oname = "{}.out".format(qid)
    if "compile_cmd" in config["commands"][args.lang]:
        compile_cmd = config["commands"][args.lang]["compile_cmd"]
        compile_cmd = compile_cmd.format(fname=fname, oname=oname)
        returncode, stdout, stderr, t, tle = run_cmd(compile_cmd, timeout=None)
        if returncode == 0:
            print("Compile Succeeded!")
        else:
            print("Compile Error!")
        print("cmd: {}".format(compile_cmd))
        if stdout:
            print("---- stdout")
            print(stdout)
        if stderr:
            print("---- stderr")
            print(stderr)
        if returncode != 0:
            sys.exit(returncode)
    test_cmd = config["commands"][args.lang]["test_cmd"]
    test_cmd = test_cmd.format(fname=fname, oname=oname)
    test_list = parse_sample(qid)
    for i in range(0, len(test_list), 2):
        test_case_in = test_list[i][1]
        test_case_out = test_list[i + 1][1]
        test_n = i // 2
        returncode, stdout, stderr, t, tle = run_cmd(test_cmd,
                                                     input_line=test_case_in,
                                                     timeout=args.time_limit)
        print_line = "Test {}: ".format(test_n)
        print_line += "\033[33;1m"
        if returncode != 0:
            print_line += "Runtime Error!"
        elif tle:
            print_line += "Timeout Error!"
        elif t > args.time_limit:
            print_line += "Time Limit Expired!"
        elif stdout != test_case_out:
            if chk_output_floatError(stdout, test_case_out):
                print_line += "Succeeded! (float error)"
            else:
                print_line += "Failed!"
        else:
            print_line += "Succeeded!"
        print_line += "\033[0m"
        print_line += " (exit code: {})".format(returncode)
        print(print_line)
        print("Time: {:.2f}s / {:.1f}s".format(t, args.time_limit))
        if stdout:
            print("---- stdout")
            print("\033[32m" + stdout + "\033[0m")
        if stderr:
            print("---- stderr")
            print("\033[32m" + stderr + "\033[0m")
        print("---- expected output")
        print("\033[32m" + test_case_out + "\033[0m")


def main(args, config):
    if args.lang is None:
        args.lang = config["default_language"]
    if args.mode in ["setup", "s"]:
        setup(args, config)
    else:
        qid = os.path.basename(os.getcwd())
        if args.mode in ["add-test", "a"]:
            add_test(args, qid)
        elif args.mode in ["test", "t"]:
            run_test(args, config, qid)


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("mode", type=str,
                        choices=["s", "setup", "a", "add-test", "t", "test"])
    parser.add_argument("-l", "--lang", default=None)
    parser.add_argument("-c", "--contest-name", default="")
    parser.add_argument("-p", "--problem-number", default=None)
    parser.add_argument("-f", "--file-name", default=None)
    parser.add_argument("-t", "--time-limit", type=int, default=2)
    args = parser.parse_args()

    script_dir = os.path.dirname(os.path.realpath(__file__))
    try:
        with open(os.path.join(script_dir, "config.json")) as f:
            config = json.loads(f.read())
    except:
        print("Couldn't read config.json file.")
        config = None

    main(args, config)
