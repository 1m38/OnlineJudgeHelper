#!/usr/bin/env python
# coding: utf-8
"""docstring"""

from __future__ import print_function
from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
import os
import sys
import re
import subprocess
import json
import shutil
import time

# compatible with Python2
if sys.version_info.major == 2:
    input = raw_input

color = {"reset"    : "\033[0m",
         "bBlack"   : "\033[30;1m",
         "bRed"     : "\033[31;1m",
         "bGreen"   : "\033[32;1m",
         "bYellow"  : "\033[33;1m",
         "bBlue"    : "\033[34;1m",
         "bMagenta" : "\033[35;1m",
         "bCyan"    : "\033[36;1m",
         "bWhite"   : "\033[37;1m",
         "Black"    : "\033[30m",
         "Red"      : "\033[31m",
         "Green"    : "\033[32m",
         "Yellow"   : "\033[33m",
         "Blue"     : "\033[34m",
         "Magenta"  : "\033[35m",
         "Cyan"     : "\033[36m",
         "White"    : "\033[37m"}

re_sample_comment = re.compile(r"/\* (.+) \*/")
re_isFloat = re.compile('^[+-]?(\d*\.\d+|\d+\.?\d*)([eE][+-]?\d+|)\Z')
re_isInt = re.compile('^(\d+)\n?\Z')

def input_lines(prompt=None):
    lines = ""
    if prompt:
        print(prompt)
    while True:
        try:
            lines += input()
            lines += "\n"
        except EOFError:
            return lines


def parse_sample(qid):
    try:
        with open(qid + ".sample", "r") as f:
            sample_txt = f.read()
    except IOError:
        print("File '{}' not found.".format(qid + ".sample"))
        sys.exit(1)
    test_list = []
    sample_id = None
    for line in sample_txt.split("\n"):
        m = re_sample_comment.match(line)
        if m:
            sample_id = m.group(1)
            test_list.append([sample_id, ""])
        elif sample_id is not None:
            test_list[-1][1] += line + "\n"
    # 末尾の改行を削除
    if sample_id is not None:
        test_list[-1][1] = test_list[-1][1][:-1]
    return test_list


def add_sample(qid, test_id, test_str, out_str):
    with open(qid + ".sample", "a") as f:
        f.write("/* Test {} */\n".format(test_id))
        f.write(test_str)
        f.write("/* Output {} */\n".format(test_id))
        f.write(out_str)
    print("Added test case {}.".format(test_id))


def setup(args, config):
    contest = args.contest_name
    pnumber = args.problem_number
    dirname = os.path.join(contest, pnumber)
    script_dir = os.path.dirname(os.path.realpath(__file__))
    template_dir = config["templates"].format(src_dir=script_dir)
    template_file = os.path.join(template_dir, "template.{}".format(args.lang))
    script_path = args.file_name if args.file_name is not None \
        else "{}.{}".format(pnumber, args.lang)
    script_path = os.path.join(dirname, script_path)
    sample_path = os.path.join(dirname, "{}.sample".format(pnumber))
    if not os.path.exists(dirname):
        os.makedirs(dirname)
    if os.path.exists(template_file):
        shutil.copyfile(template_file, script_path)
    else:
        print("Template file not found. Create blank file.")
        with open(script_path, "w") as f:
            f.write("")
    # 空のsampleファイル作成
    with open(sample_path, "w") as f:
        f.write("")


def add_test(args, qid):
    test_list = parse_sample(qid)
    test_id = int(test_list[-1][0][7:]) + 1 if len(test_list) > 0 else 0
    test_str = input_lines(prompt="TestCase {}:".format(test_id))
    out_str = input_lines(prompt="Output {}:".format(test_id))
    add_sample(qid, test_id, test_str, out_str)


def run_cmd(cmd, input_line=None, timeout=10):
    tle = False
    t = time.time()
    p = subprocess.Popen(cmd, shell=True,
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE,
                         universal_newlines=True)
    stdout_data, stderr_data = ("", "")
    try:
        stdout_data, stderr_data = p.communicate(timeout=timeout,
                                                 input=input_line)
    except subprocess.TimeoutExpired:
        tle = True
        p.kill()
        stdout_data, stderr_data = p.communicate()
    ts = time.time() - t
    return (p.returncode, stdout_data, stderr_data, ts, tle)

def chk_output_floatError(stdout, expect, err):
    result = True
    for lo, le in zip(stdout.split("\n"), expect.split("\n")):
        if re_isFloat.match(le) and not re_isInt.match(le):  # 答がint -> 完全一致
            try:
                flo = float(lo)
                fle = float(le)
            except ValueError:
                return False
            if abs(flo - fle) / max(1, abs(fle)) < err:
                result *= True
            else:
                result *= False
        else:
            result *= lo == le
    return result

def run_test(args, config, qid):
    if args.file_name:
        fname = args.file_name
    else:
        fname = "{}.{}".format(qid, args.lang)
    oname = "{}.out".format(qid)
    if "compile_cmd" in config["commands"][args.lang]:
        compile_cmd = config["commands"][args.lang]["compile_cmd"]
        compile_cmd = compile_cmd.format(fname=fname, oname=oname)
        print("cmd: {}".format(compile_cmd))
        returncode, stdout, stderr, t, tle = run_cmd(compile_cmd, timeout=None)
        if returncode == 0:
            print(color["Yellow"] + "Compile Succeeded!" + color["reset"])
        else:
            print(color["bRed"] + "Compile Error!" + color["reset"])
        if stdout:
            print("---- stdout")
            print(stdout)
        if stderr:
            print("---- stderr")
            print(stderr)
        if returncode != 0:
            sys.exit(returncode)
    test_cmd = config["commands"][args.lang]["test_cmd"]
    test_cmd = test_cmd.format(fname=fname, oname=oname)
    test_list = parse_sample(qid)
    for i in range(0, len(test_list), 2):
        test_case_in = test_list[i][1]
        test_case_out = test_list[i + 1][1]
        test_n = i // 2
        returncode, stdout, stderr, t, tle = run_cmd(test_cmd,
                                                     input_line=test_case_in,
                                                     timeout=args.time_limit)
        print_line = "Test {}: ".format(test_n)
        if tle:
            print_line += color["bRed"] + "Timeout Error!" + color["reset"]
        elif returncode != 0:
            print_line += color["bRed"] + "Runtime Error!" + color["reset"]
        elif t > args.time_limit:
            print_line += color["bRed"] + "Time Limit Expired!" + color["reset"]
        elif stdout != test_case_out:
            if chk_output_floatError(stdout, test_case_out,
                                     err=args.float_error):
                print_line += color["bYellow"] + "Succeeded! (float error)" + color["reset"]
            else:
                print_line += color["bRed"] + "Failed!" + color["reset"]
        else:
            print_line += color["bYellow"] + "Succeeded!" + color["reset"]
        print_line += " (exit code: {})".format(returncode)
        print(print_line)
        print("Time: {:.2f}s / {:.1f}s".format(t, args.time_limit))
        if stdout:
            print("---- stdout")
            print(color["Green"] + stdout + color["reset"])
        if stderr:
            print("---- stderr")
            print(color["Green"] + stderr + color["reset"])
        print("---- expected output")
        print(color["Green"] + test_case_out + color["reset"])


def main(args, config):
    if args.lang is None:
        args.lang = config["default_language"]
    if args.mode in ["setup", "s"]:
        setup(args, config)
    else:
        qid = os.path.basename(os.getcwd())
        if args.mode in ["add-test", "a"]:
            add_test(args, qid)
        elif args.mode in ["test", "t"]:
            run_test(args, config, qid)


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("mode", type=str,
                        choices=["s", "setup", "a", "add-test", "t", "test"])
    parser.add_argument("-l", "--lang", default=None)
    parser.add_argument("-c", "--contest-name", default="")
    parser.add_argument("-p", "--problem-number", default=None)
    parser.add_argument("-f", "--file-name", default=None)
    parser.add_argument("-t", "--time-limit", type=int, default=2)
    parser.add_argument("-e", "--float-error", type=float, default=1e-4)
    args = parser.parse_args()

    script_dir = os.path.dirname(os.path.realpath(__file__))
    try:
        with open(os.path.join(script_dir, "config.json")) as f:
            config = json.loads(f.read())
    except:
        print("Couldn't read config.json file.")
        config = None

    main(args, config)
